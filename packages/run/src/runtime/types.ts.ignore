type Awaitable<T> = Promise<T> | T;
type OneOrMany<T> = T | T[];
type Combine<T> = T extends object ? { [P in keyof T]: T[P] } : T;
type RequiredKeys<T> = {
  [k in keyof T]-?: undefined extends T[k] ? never : k;
}[keyof T];
type HasKeys<T> = [keyof T] extends [never] ? false : true;
type HasRequiredKeys<T> = [RequiredKeys<T>] extends [never] ? false : true;
type Equal<T, U> = T extends U ? (U extends T ? true : false) : false;
type Select<T extends any[], K extends keyof T[number]> = {
  [key in keyof T]: T[key][K];
};
type FilterOut<T extends any[], U> = T extends [infer F, ...infer R]
  ? true extends Equal<F, U>
    ? FilterOut<R, U>
    : [F, ...FilterOut<R, U>]
  : [];
type Dedupe<T extends any[]> = T extends [infer F, ...infer R]
  ? [F, ...Dedupe<FilterOut<R, F>>]
  : [];

export type CombineRoutes<T extends Route[]> = Route<
  Dedupe<Select<T, "params">>[number],
  Dedupe<Select<T, "meta">>[number],
  Select<T, "path">[number]
>;


// TODO: Figure out how to compose an array of route handler provide types
//type Composed<T extends RouteHandler[], TRoute extends Route = Route>(arr: [...T]) = RouteHandler,


export interface RouteContextExtensions {}

export interface Platform {}

export type ParamsObject = Record<string, string>;
export type InputObject = Record<PropertyKey, any>;

export interface RequestContext<T = Platform> {
  url: URL;
  method: string;
  request: Request;
  platform: T;
}

export type RouteContext<TRoute extends Route = Route> = TRoute extends any
  ? Combine<
      RouteContextExtensions &
        Readonly<
          RequestContext & {
            route: TRoute["path"];
            params: TRoute["params"];
            meta: TRoute["meta"];
          }
        >
    >
  : never;

export type NextFunction<Data extends InputObject = {}> =
  HasRequiredKeys<Data> extends true
    ? (data: Data) => Awaitable<Response>
    : HasKeys<Data> extends true
    ? (data?: Data) => Awaitable<Response>
    : () => Awaitable<Response>;

export type HandlerLike<
  TRoute extends Route = Route,
  Provides extends InputObject = {}
> = Awaitable<OneOrMany<RouteHandler<TRoute, Provides>>>;

export type RouteHandler<
  TRoute extends Route = Route,
  Provides extends InputObject = {}
> = (
  context: RouteContext<TRoute>,
  next: NextFunction<Provides>
) => HasRequiredKeys<Provides> extends true
  ? Awaitable<Response | Provides>
  : Awaitable<Response | void>;

export interface Route<
  Params extends ParamsObject = {},
  Meta = unknown,
  Path extends string = string
> {
  path: Path;
  params: Params;
  meta: Meta;
}

export interface RouteWithHandler<
  Params extends ParamsObject = {},
  Meta = unknown,
  Path extends string = string
> extends Route<Params, Meta, Path> {
  handler: RouteHandler<this>;
}

export type MatchRoute = (
  method: string,
  pathname: string
) => RouteWithHandler | null;

export type Router<T = Platform> = (
  context: RequestContext<T>
) => Promise<Response | void>;

export type InvokeRoute<T = Platform> = (
  route: Route | null,
  context: RequestContext<T>
) => Promise<Response | void>;
