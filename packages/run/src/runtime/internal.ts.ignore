import type {
  InputObject,
  Loader,
  NextFunction,
  Route,
  RouteContext,
  RouteHandler,
} from "./types";

globalThis.Marko ??= {} as any;
globalThis.Marko.route = (handler) => handler;

const loadersMap = new WeakMap<RouteContext, Loader[]>();

export function createInput(context: RouteContext) {
  const loaders: Loader[] = [];
  loadersMap.set(context, loaders);
  return (loader?: Loader | InputObject): InputObject => {
    const input = loaders.reduce<InputObject>(
      (acc, fn) => Object.assign(acc, fn()),
      loader ? (typeof loader === "function" ? loader() : loader) : {}
    );
    input.$global ??= {};
    input.$global.context = context;
    return input;
  };
}

export async function call(
  handler: RouteHandler<Route, any>,
  next: NextFunction<any>,
  context: RouteContext,
  loader?: Loader
): Promise<Response> {
  let response: Loader | Response | void;

  loader && loadersMap.get(context)!.push(loader);

  if (process.env.NODE_ENV !== "production") {
    let nextCallCount = 0;
    let hasResponse = false;
    try {
      response = await handler(context, (data) => {
        nextCallCount++;
        return next(data);
      });
      hasResponse = !!response;
    } catch (err) {
      hasResponse = true;
      if (err instanceof Response) {
        return err;
      }
      throw err;
    } finally {
      if (!hasResponse && nextCallCount > 0) {
        console.warn(
          `Handler '${handler.name}' called its next function but no response was returned. ` +
            "This will cause the next function to be called again which is wasteful. " +
            "Either return or throw the result of calling `next`, return or throw a " +
            "new Response object or finally `throw null` to skip handling the request"
        );
      } else if (nextCallCount > 1) {
        console.warn(
          `Handler '${handler.name}' called its next function more than once. ` +
            "Make sure this is intentional because it is inefficient."
        );
      }
    }
  } else {
    try {
      response = await handler(context, next);
    } catch (err) {
      if (err instanceof Response) {
        return err;
      }
      throw err;
    }
  }

  if (typeof response === "function") {
    return (next as NextFunction<any>)(response);
  }
  return response || (next as NextFunction)();
}

// export async function call(
//   handler: RouteHandler,
//   next: NextFunction,
//   context: RouteContext,
//   locals: Record<string, any>,
//   data?: Record<string, any>
// ): Promise<Response> {
//   let response: Response | void;
//   try {
//     response = await handler(
//       context,
//       data ? Object.assign(locals, data) : locals,
//       next
//     );
//   } catch (err) {
//     if (err instanceof Response) {
//       return err;
//     }
//     throw err;
//   }
//   return response || next();
// }

export function compose(handlers: RouteHandler[]): RouteHandler {
  const len = handlers.length;
  if (!len) {
    return (_context, next) => next();
  } else if (len === 1) {
    return handlers[0];
  }
  return (context, next: NextFunction<any>) => {
    let i = 0;
    return (function nextHandler(loader?: Loader) {
      return i < len
        ? call(handlers[i++], nextHandler, context, loader)
        : next(loader);
    })();
  };
}

export function normalize(
  obj: RouteHandler | RouteHandler[] | Promise<RouteHandler | RouteHandler[]>
): RouteHandler {
  if (typeof obj === "function") {
    return obj;
  } else if (Array.isArray(obj)) {
    return compose(obj);
  } else if (obj instanceof Promise) {
    const promise = obj.then((value) => {
      fn = Array.isArray(value) ? compose(value) : value;
    });
    let fn: RouteHandler = async (context, next) => {
      await promise;
      return fn(context, next);
    };
    return (context, next) => fn(context, next);
  }
  throw new Error(
    `Invalid handler - expected function, array or Promise but received ${obj}`
  );
}

export function noContent() {
  return new Response(null, {
    status: 204,
  });
}

export function notHandled() {
  throw null;
}
